server {  
  # Define a new server block (like a virtual host) that will handle incoming requests

  listen 80;  
  # Listen on port 80 (standard HTTP port).  
  # Any request coming via http:// will be handled here.

  server_name _;  
  # The underscore means "catch-all".  
  # If no other server_name matches, this one is used (default server).

  # ---------------------- FRONTEND STATIC FILES ----------------------

  root /usr/share/nginx/html;  
  # Root directory where static frontend files are stored.  
  # Example: request /style.css → serve /usr/share/nginx/html/style.css

  index index.html;  
  # Default file to serve when a directory is requested.  
  # Example: visiting / will return index.html

  # ---------------------- STATIC ASSET CACHING ----------------------

  location ~* \.(?:js|css|png|jpg|jpeg|gif|ico|svg|woff2?)$ {  
    # This block handles requests for static asset files.  
    # "~*" means regex match (case-insensitive).  
    # Matches extensions like .js, .css, .png, .jpg, .woff2, etc.

    expires 30d;  
    # Tell the browser to cache these files for 30 days.  
    # Reduces server load and speeds up repeat visits.

    add_header Cache-Control "public, max-age=2592000, immutable";  
    # Adds caching header:  
    # - public → allows caching in browsers and CDNs  
    # - max-age=2592000 → 30 days in seconds  
    # - immutable → browser assumes the file won’t change (good for versioned assets)

    try_files $uri =404;  
    # Check if the requested file exists.  
    # If yes → serve it. If not → return 404 Not Found.
  }

  # ---------------------- FRONTEND SPA ROUTING ----------------------

  location / {  
    # This block handles all other frontend routes (for SPAs like React/Vue).  

    try_files $uri /index.html;  
    # First: check if the request matches a file.  
    # If not, fall back to index.html (so SPA router handles it).  
    # Example: /dashboard → serves index.html, JS frontend handles /dashboard.
  }

  # ---------------------- BACKEND API PROXY ----------------------

  location /api/ {  
    # This block proxies all requests starting with /api/ to the backend server.  
    # Example: /api/users → goes to backend service.

    proxy_http_version 1.1;  
    # Use HTTP/1.1 for proxying.  
    # Required for keep-alive connections and streaming (like SSE or WebSockets).

    proxy_set_header Host $host;  
    # Pass the original Host header to backend (so backend knows domain).

    proxy_set_header X-Real-IP $remote_addr;  
    # Pass client’s actual IP address (so backend knows who is calling).

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  
    # Preserve full chain of client IPs if request goes through multiple proxies.

    proxy_set_header X-Forwarded-Proto $scheme;  
    # Tell backend whether client connected with http or https.

    proxy_pass http://backend:3001/;  
    # Forward the request to backend server at hostname "backend", port 3001.  
    # "backend" is usually a Docker container name or DNS host.  
    # Example: /api/users → http://backend:3001/users.

    # --- STREAMING / REAL-TIME SETTINGS ---

    proxy_buffering off;  
    # Disable response buffering in Nginx.  
    # Ensures data is sent to client immediately (needed for streaming APIs).

    proxy_cache off;  
    # Disable caching for API responses (since API data is dynamic).

    chunked_transfer_encoding on;  
    # Allow sending responses in chunks.  
    # Important for large or streaming responses (AI models, SSE, etc.).

    proxy_read_timeout 3600s;  
    # Allow backend responses to take up to 1 hour.  
    # Prevents timeout for long-running requests (like large uploads/streams).

    send_timeout 3600s;  
    # Allow Nginx to wait up to 1 hour when sending data to the client.  
    # Prevents client connection timeout during long downloads or streams.
  }
}
